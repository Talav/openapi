{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OpenAPI - Automatic Specification Generation","text":"<p>Generate OpenAPI 3.0.4 and 3.1.2 specifications from Go structs.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Type-Driven - Define request/response structures, get specs automatically</li> <li>Multiple Versions - Support for OpenAPI 3.0.4 and 3.1.2</li> <li>Rich Metadata - Six tag systems give you complete control</li> <li>Validation Integration - Validation rules become schema constraints</li> <li>Security Schemes - Built-in support for all OpenAPI auth types</li> <li>Examples - Auto-generated or custom examples</li> <li>Extensible - Hooks for custom schema transformations</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/talav/openapi\"\n)\n\ntype User struct {\n    ID    int    `json:\"id\"`\n    Name  string `json:\"name\" validate:\"required\"`\n    Email string `json:\"email\" validate:\"required,email\"`\n}\n\ntype CreateUserRequest struct {\n    Body User `body:\"structured\"`\n}\n\nfunc main() {\n    api := openapi.NewAPI(\n        openapi.WithInfoTitle(\"User API\"),\n        openapi.WithInfoVersion(\"1.0.0\"),\n    )\n\n    result, _ := api.Generate(context.Background(),\n        openapi.POST(\"/users\",\n            openapi.WithRequest(CreateUserRequest{}),\n            openapi.WithResponse(201, User{}),\n        ),\n    )\n\n    fmt.Println(string(result.JSON))\n}\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started - Installation and first steps</li> <li>Guides - Feature guides and examples</li> <li>Advanced - Hooks, custom tags, debugging</li> </ul>"},{"location":"#why-openapi-generation","title":"Why OpenAPI Generation?","text":"<p>Hand-writing OpenAPI specs is tedious and error-prone. This library:</p> <ol> <li>Eliminates duplication - Your Go structs are the source of truth</li> <li>Catches errors early - Type safety at compile time</li> <li>Keeps code and docs in sync - They can't drift apart</li> <li>Reduces maintenance - Update structs, regenerate specs</li> </ol>"},{"location":"#tag-system","title":"Tag System","text":"<p>The library extracts metadata from struct tags:</p> <ul> <li><code>json</code> - Property names</li> <li><code>schema</code> - Parameter names, locations, and styles</li> <li><code>body</code> - Request/response body marker</li> <li><code>validate</code> - Validation rules become constraints</li> <li><code>openapi</code> - Descriptions, examples, and metadata</li> <li><code>default</code> - Default values</li> <li><code>requires</code> - Conditional required fields</li> </ul> <p>Learn more in Core Concepts.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>go get github.com/talav/openapi\n</code></pre> <p>Continue to Quick Start \u2192</p>"},{"location":"advanced/custom-tags/","title":"Custom Tags","text":"<p>Customize built-in tag names with <code>WithTagConfig</code>.</p> <p>This page documents the real public extensibility in this package: renaming the built-in tags. It does not expose a public API for registering arbitrary custom tag parsers.</p>"},{"location":"advanced/custom-tags/#what-is-supported","title":"What Is Supported","text":"<p><code>WithTagConfig</code> lets you rename these built-in tags:</p> <ul> <li><code>schema</code></li> <li><code>body</code></li> <li><code>openapi</code></li> <li><code>validate</code></li> <li><code>default</code></li> <li><code>requires</code></li> </ul> <pre><code>import \"github.com/talav/openapi/config\"\n\napi := openapi.NewAPI(\n    openapi.WithTagConfig(config.TagConfig{\n        Schema:   \"param\",\n        Body:     \"payload\",\n        OpenAPI:  \"api\",\n        Validate: \"rules\",\n        Default:  \"def\",\n        Requires: \"needs\",\n    }),\n)\n</code></pre> <p>Then your structs use those names:</p> <pre><code>type Request struct {\n    ID   int  `param:\"id,location=path\"`\n    Body User `payload:\"structured\"`\n\n    Name string `json:\"name\" rules:\"required\" api:\"description=User name\"`\n}\n</code></pre>"},{"location":"advanced/custom-tags/#partial-configuration","title":"Partial Configuration","text":"<p>You only need to set fields you want to override:</p> <pre><code>api := openapi.NewAPI(\n    openapi.WithTagConfig(config.TagConfig{\n        Validate: \"rules\",\n    }),\n)\n</code></pre> <p>Unspecified tag names keep their defaults.</p>"},{"location":"advanced/custom-tags/#default-tag-names","title":"Default Tag Names","text":"<p>By default:</p> <pre><code>config.DefaultTagConfig()\n// Schema: \"schema\"\n// Body: \"body\"\n// OpenAPI: \"openapi\"\n// Validate: \"validate\"\n// Default: \"default\"\n// Requires: \"requires\"\n</code></pre>"},{"location":"advanced/custom-tags/#when-custom-tags-make-sense","title":"When Custom Tags Make Sense","text":"<ul> <li>You already use a conflicting <code>validate</code> tag format.</li> <li>You need naming consistency with an existing codebase.</li> </ul> <p>Example conflict resolution:</p> <pre><code>type User struct {\n    Email string `validate:\"custom_email_rule\"` // Existing library usage\n}\n\napi := openapi.NewAPI(\n    openapi.WithTagConfig(config.TagConfig{\n        Validate: \"openapi_validate\",\n    }),\n)\n\ntype User struct {\n    Email string `validate:\"custom_email_rule\" openapi_validate:\"required,email\"`\n}\n</code></pre>"},{"location":"advanced/custom-tags/#what-is-not-publicly-exposed","title":"What Is Not Publicly Exposed","text":"<p>Registering arbitrary custom tag parsers is not part of the stable public API of this package.</p> <p>If you need deeper schema customization, use documented hooks:</p> <ul> <li>Hooks</li> </ul>"},{"location":"advanced/hooks/","title":"Schema Hooks","text":"<p>Transform schemas programmatically using hooks.</p>"},{"location":"advanced/hooks/#overview","title":"Overview","text":"<p>Schema hooks let you customize how types are converted to OpenAPI schemas. Use them for:</p> <ul> <li>Custom type mappings</li> <li>Adding computed properties</li> <li>Modifying existing schemas</li> <li>Supporting domain-specific types</li> </ul>"},{"location":"advanced/hooks/#the-schematransformer-interface","title":"The SchemaTransformer Interface","text":"<p>Implement this interface to modify schemas after generation:</p> <pre><code>type SchemaTransformer interface {\n    TransformSchema(schema *Schema) (*Schema, error)\n}\n</code></pre>"},{"location":"advanced/hooks/#basic-example","title":"Basic Example","text":"<pre><code>import \"github.com/talav/openapi/hook\"\n\ntype User struct {\n    ID   int    `json:\"id\"`\n    Name string `json:\"name\"`\n}\n\nfunc (User) TransformSchema(schema *hook.Schema) (*hook.Schema, error) {\n    // Add a custom property\n    schema.Extensions = map[string]any{\n        \"x-resource-type\": \"user\",\n        \"x-searchable\":    true,\n    }\n\n    return schema, nil\n}\n</code></pre> <p>Now when <code>User</code> is used, the generated schema includes your extensions.</p>"},{"location":"advanced/hooks/#modifying-properties","title":"Modifying Properties","text":"<pre><code>type Product struct {\n    ID    int     `json:\"id\"`\n    Price float64 `json:\"price\"`\n}\n\nfunc (Product) TransformSchema(schema *hook.Schema) (*hook.Schema, error) {\n    // Add currency information to price field\n    if priceSchema, ok := schema.Properties[\"price\"]; ok {\n        priceSchema.Extensions = map[string]any{\n            \"x-currency\": \"USD\",\n        }\n    }\n\n    // Add computed field\n    schema.Properties[\"price_formatted\"] = &amp;hook.Schema{\n        Type:        \"string\",\n        Description: \"Formatted price with currency symbol\",\n        Examples:    []any{\"$9.99\"},\n        Extensions: map[string]any{\n            \"x-computed\": true,\n        },\n    }\n\n    return schema, nil\n}\n</code></pre>"},{"location":"advanced/hooks/#the-schemaprovider-interface","title":"The SchemaProvider Interface","text":"<p>Implement this to completely replace schema generation:</p> <pre><code>type SchemaProvider interface{\n    ProvideSchema() (*Schema, error)\n}\n</code></pre>"},{"location":"advanced/hooks/#custom-schema","title":"Custom Schema","text":"<pre><code>type CustomID string\n\nfunc (CustomID) ProvideSchema() (*hook.Schema, error) {\n    return &amp;hook.Schema{\n        Type:        \"string\",\n        Format:      \"uuid\",\n        Pattern:     \"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\",\n        Description: \"UUID v4 identifier\",\n        Examples:    []any{\"550e8400-e29b-41d4-a716-446655440000\"},\n    }, nil\n}\n\ntype User struct {\n    ID   CustomID `json:\"id\"`\n    Name string   `json:\"name\"`\n}\n</code></pre> <p>The <code>ID</code> field will use your custom schema instead of the default string schema.</p>"},{"location":"advanced/hooks/#real-world-examples","title":"Real-World Examples","text":""},{"location":"advanced/hooks/#enum-types","title":"Enum Types","text":"<pre><code>type Status int\n\nconst (\n    StatusPending Status = iota\n    StatusActive\n    StatusClosed\n)\n\nfunc (Status) ProvideSchema() (*hook.Schema, error) {\n    return &amp;hook.Schema{\n        Type:        \"string\",\n        Enum:        []any{\"pending\", \"active\", \"closed\"},\n        Description: \"Status of the resource\",\n    }, nil\n}\n</code></pre>"},{"location":"advanced/hooks/#time-types","title":"Time Types","text":"<pre><code>type Timestamp time.Time\n\nfunc (Timestamp) ProvideSchema() (*hook.Schema, error) {\n    return &amp;hook.Schema{\n        Type:        \"string\",\n        Format:      \"date-time\",\n        Description: \"ISO 8601 timestamp\",\n        Examples:    []any{\"2024-03-15T10:30:00Z\"},\n    }, nil\n}\n</code></pre>"},{"location":"advanced/hooks/#money-types","title":"Money Types","text":"<pre><code>type Money struct {\n    Amount   int    `json:\"amount\"`   // cents\n    Currency string `json:\"currency\"`\n}\n\nfunc (Money) TransformSchema(schema *hook.Schema) (*hook.Schema, error) {\n    // Add description\n    schema.Description = \"Money amount in smallest currency unit (e.g., cents for USD)\"\n\n    // Add example\n    schema.Example = map[string]any{\n        \"amount\":   999,\n        \"currency\": \"USD\",\n    }\n\n    // Mark currency as required\n    schema.Required = []string{\"amount\", \"currency\"}\n\n    // Add constraints\n    if amountSchema, ok := schema.Properties[\"amount\"]; ok {\n        amountSchema.Minimum = &amp;hook.Bound{Value: 0}\n        amountSchema.Description = \"Amount in smallest currency unit (cents)\"\n    }\n\n    if currencySchema, ok := schema.Properties[\"currency\"]; ok {\n        currencySchema.Pattern = \"^[A-Z]{3}$\"\n        currencySchema.Description = \"ISO 4217 currency code\"\n        currencySchema.Examples = []any{\"USD\", \"EUR\", \"GBP\"}\n    }\n\n    return schema, nil\n}\n</code></pre>"},{"location":"advanced/hooks/#polymorphic-types","title":"Polymorphic Types","text":"<pre><code>type Event struct {\n    Type string `json:\"type\"`\n    Data any    `json:\"data\"`\n}\n\nfunc (Event) TransformSchema(schema *hook.Schema) (*hook.Schema, error) {\n    // Add discriminator for polymorphism\n    schema.Discriminator = &amp;hook.Discriminator{\n        PropertyName: \"type\",\n        Mapping: map[string]string{\n            \"user_created\":  \"#/components/schemas/UserCreatedEvent\",\n            \"user_updated\":  \"#/components/schemas/UserUpdatedEvent\",\n            \"user_deleted\":  \"#/components/schemas/UserDeletedEvent\",\n        },\n    }\n\n    return schema, nil\n}\n</code></pre>"},{"location":"advanced/hooks/#database-ids","title":"Database IDs","text":"<pre><code>type DatabaseID int64\n\nfunc (DatabaseID) ProvideSchema() (*hook.Schema, error) {\n    return &amp;hook.Schema{\n        Type:        \"integer\",\n        Format:      \"int64\",\n        Minimum:     &amp;hook.Bound{Value: 1},\n        Description: \"Database primary key\",\n        Examples:    []any{1, 42, 1000},\n        Extensions: map[string]any{\n            \"x-database-type\": \"BIGINT\",\n        },\n    }, nil\n}\n</code></pre>"},{"location":"advanced/hooks/#error-handling","title":"Error Handling","text":"<p>Return errors from hooks when transformation fails:</p> <pre><code>func (User) TransformSchema(schema *hook.Schema) (*hook.Schema, error) {\n    if schema == nil {\n        return nil, fmt.Errorf(\"schema cannot be nil\")\n    }\n\n    // Validate schema before transforming\n    if schema.Type != \"object\" {\n        return nil, fmt.Errorf(\"User schema must be an object, got %s\", schema.Type)\n    }\n\n    // Transform...\n\n    return schema, nil\n}\n</code></pre>"},{"location":"advanced/hooks/#combining-hooks-with-tags","title":"Combining Hooks with Tags","text":"<p>Hooks work alongside struct tags:</p> <pre><code>type Product struct {\n    ID    int     `json:\"id\" openapi:\"readOnly\"`\n    Price float64 `json:\"price\" validate:\"min=0\"`\n}\n\nfunc (Product) TransformSchema(schema *hook.Schema) (*hook.Schema, error) {\n    // Tags are already applied, now add more\n    schema.Extensions = map[string]any{\n        \"x-resource\": \"product\",\n    }\n\n    return schema, nil\n}\n</code></pre> <p>Execution order: 1. Generate base schema from Go type 2. Apply struct tag metadata (json, validate, openapi, etc.) 3. Call <code>TransformSchema</code> if implemented</p>"},{"location":"advanced/hooks/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"advanced/hooks/#conditional-properties","title":"Conditional Properties","text":"<pre><code>func (Order) TransformSchema(schema *hook.Schema) (*hook.Schema, error) {\n    // Add conditional validation in OpenAPI 3.1\n    schema.If = &amp;hook.Schema{\n        Properties: map[string]*hook.Schema{\n            \"payment_method\": {\n                Const: \"credit_card\",\n            },\n        },\n    }\n\n    schema.Then = &amp;hook.Schema{\n        Required: []string{\"card_number\", \"cvv\"},\n    }\n\n    return schema, nil\n}\n</code></pre>"},{"location":"advanced/hooks/#computed-fields","title":"Computed Fields","text":"<pre><code>func (User) TransformSchema(schema *hook.Schema) (*hook.Schema, error) {\n    // Add virtual/computed fields\n    schema.Properties[\"full_name\"] = &amp;hook.Schema{\n        Type:        \"string\",\n        Description: \"Computed from first_name and last_name\",\n        ReadOnly:    true,\n        Extensions: map[string]any{\n            \"x-computed\": true,\n        },\n    }\n\n    return schema, nil\n}\n</code></pre>"},{"location":"advanced/hooks/#schema-versioning","title":"Schema Versioning","text":"<pre><code>func (User) TransformSchema(schema *hook.Schema) (*hook.Schema, error) {\n    // Add version information\n    schema.Extensions = map[string]any{\n        \"x-schema-version\": \"2.0\",\n        \"x-deprecated-fields\": []string{\"username\"},\n    }\n\n    // Mark deprecated fields\n    if usernameSchema, ok := schema.Properties[\"username\"]; ok {\n        usernameSchema.Deprecated = true\n        usernameSchema.Description += \" (deprecated: use email instead)\"\n    }\n\n    return schema, nil\n}\n</code></pre>"},{"location":"advanced/hooks/#testing-hooks","title":"Testing Hooks","text":"<pre><code>func TestUserSchemaTransform(t *testing.T) {\n    user := User{}\n\n    // Generate base schema (you'll need access to internal build package)\n    schema := &amp;hook.Schema{\n        Type: \"object\",\n        Properties: map[string]*hook.Schema{\n            \"id\":   {Type: \"integer\"},\n            \"name\": {Type: \"string\"},\n        },\n    }\n\n    // Apply transformation\n    result, err := user.TransformSchema(schema)\n    require.NoError(t, err)\n\n    // Verify extensions\n    assert.Equal(t, \"user\", result.Extensions[\"x-resource-type\"])\n    assert.True(t, result.Extensions[\"x-searchable\"].(bool))\n}\n</code></pre>"},{"location":"advanced/hooks/#next-steps","title":"Next Steps","text":"<ul> <li>Custom Tags - Extend the tag system</li> </ul>"},{"location":"getting-started/concepts/","title":"Core Concepts","text":"<p>Understanding how the library transforms Go structs into OpenAPI specifications.</p>"},{"location":"getting-started/concepts/#the-tag-system","title":"The Tag System","text":"<p>The library uses multiple struct tags, each with a specific purpose:</p>"},{"location":"getting-started/concepts/#1-json-property-names","title":"1. <code>json</code> - Property Names","text":"<p>Standard Go tag for JSON field names, used to name properties in schemas:</p> <pre><code>type User struct {\n    ID   int    `json:\"id\"`           // Property: \"id\"\n    Name string `json:\"name\"`         // Property: \"name\"\n    Age  int    `json:\"age,omitempty\"` // Property: \"age\" (omitempty ignored)\n}\n</code></pre>"},{"location":"getting-started/concepts/#2-schema-parameter-metadata","title":"2. <code>schema</code> - Parameter Metadata","text":"<p>Defines where parameters come from and how they're serialized:</p> <pre><code>type Request struct {\n    ID      string `schema:\"id,location=path\"`        // Path parameter\n    Search  string `schema:\"q,location=query\"`        // Query parameter\n    APIKey  string `schema:\"X-API-Key,location=header\"` // Header\n    Session string `schema:\"session,location=cookie\"`   // Cookie\n}\n</code></pre> <p>Learn more: Tag Reference (talav/schema)</p>"},{"location":"getting-started/concepts/#3-body-requestresponse-bodies","title":"3. <code>body</code> - Request/Response Bodies","text":"<p>Marks which field contains the body:</p> <pre><code>type CreateUserRequest struct {\n    Body User `body:\"structured\"` // JSON/XML/form body\n}\n\ntype FileUploadRequest struct {\n    Body []byte `body:\"file\"` // Binary file upload\n}\n</code></pre>"},{"location":"getting-started/concepts/#4-validate-validation-rules","title":"4. <code>validate</code> - Validation Rules","text":"<p>Validation tags transform into OpenAPI schema constraints:</p> <pre><code>type User struct {\n    Name  string `json:\"name\" validate:\"required,min=3,max=50\"`\n    Email string `json:\"email\" validate:\"required,email\"`\n    Age   int    `json:\"age\" validate:\"min=18,max=120\"`\n}\n</code></pre> <p>Becomes:</p> <pre><code>{\n  \"name\": {\n    \"type\": \"string\",\n    \"minLength\": 3,\n    \"maxLength\": 50\n  },\n  \"email\": {\n    \"type\": \"string\",\n    \"format\": \"email\"\n  },\n  \"age\": {\n    \"type\": \"integer\",\n    \"minimum\": 18,\n    \"maximum\": 120\n  },\n  \"required\": [\"name\", \"email\"]\n}\n</code></pre> <p>Learn more: Validation</p>"},{"location":"getting-started/concepts/#5-openapi-openapi-metadata","title":"5. <code>openapi</code> - OpenAPI Metadata","text":"<p>Additional OpenAPI-specific properties:</p> <pre><code>type Product struct {\n    ID    string  `json:\"id\" openapi:\"readOnly\"`\n    Name  string  `json:\"name\" openapi:\"title=Product Name,description=Display name\"`\n    Price float64 `json:\"price\" openapi:\"examples=9.99|19.99|29.99\"`\n}\n</code></pre> <p>Learn more: Metadata</p>"},{"location":"getting-started/concepts/#6-default-default-values","title":"6. <code>default</code> - Default Values","text":"<p>Specify defaults for optional fields:</p> <pre><code>type Config struct {\n    Host string `json:\"host\" default:\"localhost\"`\n    Port int    `json:\"port\" default:\"8080\"`\n}\n</code></pre>"},{"location":"getting-started/concepts/#7-requires-conditional-requirements","title":"7. <code>requires</code> - Conditional Requirements","text":"<p>Fields that become required when another field is present:</p> <pre><code>type PaymentRequest struct {\n    Method      string `json:\"method\"`\n    CardNumber  string `json:\"card_number\" requires:\"cvv,expiry\"`\n    CVV         string `json:\"cvv\"`\n    Expiry      string `json:\"expiry\"`\n}\n</code></pre> <p>When <code>card_number</code> is provided, both <code>cvv</code> and <code>expiry</code> become required.</p>"},{"location":"getting-started/concepts/#how-it-works","title":"How It Works","text":"<p>The generation process:</p> <ol> <li>Parse struct metadata - Extract tags and reflect on types</li> <li>Build operations - Create paths, parameters, request bodies</li> <li>Generate schemas - Transform validation rules, apply metadata</li> <li>Validate spec - Check against OpenAPI 3.0/3.1 schema</li> <li>Return JSON/YAML - Serialized specification</li> </ol>"},{"location":"getting-started/concepts/#request-vs-response-mapping","title":"Request vs Response Mapping","text":""},{"location":"getting-started/concepts/#request-structs","title":"Request Structs","text":"<p>Request structs can have parameters and a body:</p> <pre><code>type CreatePostRequest struct {\n    OrgID  string `schema:\"org_id,location=path\"` // Parameter\n    APIKey string `schema:\"X-API-Key,location=header\"` // Parameter\n    Body struct {\n        Title   string `json:\"title\" validate:\"required\"`\n        Content string `json:\"content\" validate:\"required\"`\n    } `body:\"structured\"` // Request body\n}\n</code></pre>"},{"location":"getting-started/concepts/#response-structs","title":"Response Structs","text":"<p>Response structs can use either pattern:</p> <p>Simple pattern - the struct is the response body:</p> <pre><code>type User struct {\n    ID   int    `json:\"id\"`\n    Name string `json:\"name\"`\n}\n\nopenapi.WithResponse(200, User{}) // User becomes the response schema\n</code></pre> <p>Advanced pattern - use body tag for headers:</p> <pre><code>type UserResponse struct {\n    ETag string `schema:\"ETag,location=header\"` // Response header\n    Body User   `body:\"structured\"`              // Response body\n}\n\nopenapi.WithResponse(200, UserResponse{}) // Includes headers\n</code></pre>"},{"location":"getting-started/concepts/#response-patterns","title":"Response Patterns","text":"<p>The library supports two patterns for responses:</p>"},{"location":"getting-started/concepts/#simple-pattern-most-common","title":"Simple Pattern (Most Common)","text":"<p>Pass your response struct directly - the entire struct becomes the response body:</p> <pre><code>type User struct {\n    ID   int    `json:\"id\"`\n    Name string `json:\"name\"`\n}\n\ntype ErrorResponse struct {\n    Message string `json:\"message\"`\n    Code    string `json:\"code\"`\n}\n\nopenapi.GET(\"/users/:id\",\n    openapi.WithResponse(200, User{}),           // \u2705 Simple\n    openapi.WithResponse(404, ErrorResponse{}),  // \u2705 Simple\n)\n</code></pre>"},{"location":"getting-started/concepts/#advanced-pattern-with-response-headers","title":"Advanced Pattern (With Response Headers)","text":"<p>Use the <code>body</code> tag wrapper when you need to include response headers:</p> <pre><code>type UserWithHeaders struct {\n    ETag         string `schema:\"ETag,location=header\"`\n    CacheControl string `schema:\"Cache-Control,location=header\"`\n    Body         User   `body:\"structured\"`\n}\n\nopenapi.GET(\"/users/:id\",\n    openapi.WithResponse(200, UserWithHeaders{}), // Includes headers\n)\n</code></pre> <p>Use the wrapper pattern only when you need response headers. For standard responses, use the simple pattern.</p>"},{"location":"getting-started/concepts/#custom-content-types","title":"Custom Content Types","text":"<p>By default, responses use <code>application/json</code>. To return a different content type, implement the <code>ContentTypeProvider</code> interface on your response struct:</p> <pre><code>type ProblemDetail struct {\n    Type   string `json:\"type\"`\n    Title  string `json:\"title\"`\n    Status int    `json:\"status\"`\n    Detail string `json:\"detail\"`\n}\n\n// ContentTypeProvider interface\nfunc (ProblemDetail) ContentType(defaultType string) string {\n    return \"application/problem+json\"\n}\n\nopenapi.GET(\"/users/:id\",\n    openapi.WithResponse(404, ProblemDetail{}),\n)\n</code></pre> <p>The generated OpenAPI spec will use <code>application/problem+json</code> instead of <code>application/json</code> for this response.</p> <p>Common use cases:</p> <ul> <li>RFC 7807 Problem Details: <code>application/problem+json</code></li> <li>HAL responses: <code>application/hal+json</code></li> <li>JSON:API: <code>application/vnd.api+json</code></li> <li>Custom vendor types: <code>application/vnd.myapp+json</code></li> </ul> <p>The method receives the default content type as a parameter, allowing conditional logic:</p> <pre><code>func (r APIResponse) ContentType(defaultType string) string {\n    if r.IsError {\n        return \"application/problem+json\"\n    }\n    return defaultType // Use default application/json\n}\n</code></pre>"},{"location":"getting-started/concepts/#schema-generation","title":"Schema Generation","text":""},{"location":"getting-started/concepts/#type-mapping","title":"Type Mapping","text":"<p>Go types map to OpenAPI/JSON Schema types:</p> Go Type OpenAPI Type Format <code>string</code> string - <code>int</code>, <code>int32</code> integer int32 <code>int64</code> integer int64 <code>float32</code> number float <code>float64</code> number double <code>bool</code> boolean - <code>[]T</code> array items: T <code>map[string]T</code> object additionalProperties: T <code>struct</code> object properties: fields <code>[]byte</code> string binary (files) or base64 (JSON)"},{"location":"getting-started/concepts/#nested-structures","title":"Nested Structures","text":"<p>Nested structs become nested schemas:</p> <pre><code>type User struct {\n    Name    string  `json:\"name\"`\n    Address Address `json:\"address\"`\n}\n\ntype Address struct {\n    Street string `json:\"street\"`\n    City   string `json:\"city\"`\n}\n</code></pre> <p>The <code>Address</code> type becomes a reusable component referenced via <code>$ref</code>.</p>"},{"location":"getting-started/concepts/#component-reuse","title":"Component Reuse","text":"<p>Types used in multiple places are generated once:</p> <pre><code>type User struct {\n    ID   int    `json:\"id\"`\n    Name string `json:\"name\"`\n}\n\n// User appears in both operations\nopenapi.POST(\"/users\",\n    openapi.WithResponse(201, User{}),\n),\nopenapi.GET(\"/users/:id\",\n    openapi.WithResponse(200, User{}),\n)\n</code></pre> <p><code>User</code> appears once in <code>components/schemas</code> and is referenced from both operations.</p>"},{"location":"getting-started/concepts/#openapi-versions","title":"OpenAPI Versions","text":"<p>Choose your target version:</p> <pre><code>// OpenAPI 3.0.4 (maximum compatibility)\napi := openapi.NewAPI(\n    openapi.WithVersion(\"3.0.4\"),\n)\n\n// OpenAPI 3.1.2 (modern features)\napi := openapi.NewAPI(\n    openapi.WithVersion(\"3.1.2\"),\n)\n</code></pre> <p>Learn more: OpenAPI Versions</p>"},{"location":"getting-started/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Tag Reference (talav/schema) - Master <code>schema</code>/<code>body</code> tag semantics</li> <li>Validation - Transform validation rules</li> <li>Metadata - Add rich documentation</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#install-the-library","title":"Install the Library","text":"<pre><code>go get github.com/talav/openapi\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Create a test file to confirm everything works:</p> <pre><code>// main.go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/talav/openapi\"\n)\n\nfunc main() {\n    api := openapi.NewAPI(\n        openapi.WithInfoTitle(\"Test API\"),\n        openapi.WithInfoVersion(\"1.0.0\"),\n    )\n\n    result, err := api.Generate(context.Background())\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(\"\u2713 OpenAPI library installed successfully\")\n    fmt.Printf(\"Generated %d bytes of OpenAPI spec\\n\", len(result.JSON))\n}\n</code></pre> <p>Run it:</p> <pre><code>go run main.go\n</code></pre> <p>You should see:</p> <pre><code>\u2713 OpenAPI library installed successfully\nGenerated 106 bytes of OpenAPI spec\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Build your first API spec</li> <li>Core Concepts - Understand how it works</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Let's build a complete OpenAPI specification for a user management API.</p>"},{"location":"getting-started/quick-start/#define-your-types","title":"Define Your Types","text":"<p>Start by defining request and response structures:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/talav/openapi\"\n)\n\n// Domain models\ntype User struct {\n    ID    int    `json:\"id\"`\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}\n\ntype ErrorResponse struct {\n    Message string `json:\"message\"`\n    Code    string `json:\"code\"`\n}\n\n// Request types\ntype GetUserRequest struct {\n    ID int `schema:\"id,location=path\"`\n}\n\ntype CreateUserRequest struct {\n    Body struct {\n        Name  string `json:\"name\" validate:\"required,min=3\"`\n        Email string `json:\"email\" validate:\"required,email\"`\n    } `body:\"structured\"`\n}\n\ntype UpdateUserRequest struct {\n    ID   int `schema:\"id,location=path\"`\n    Body struct {\n        Name  string `json:\"name\"`\n        Email string `json:\"email\" validate:\"email\"`\n    } `body:\"structured\"`\n}\n</code></pre>"},{"location":"getting-started/quick-start/#generate-the-specification","title":"Generate the Specification","text":"<p>Create the API instance and define operations:</p> <pre><code>func main() {\n    // Create API with metadata\n    api := openapi.NewAPI(\n        openapi.WithInfoTitle(\"User Management API\"),\n        openapi.WithInfoVersion(\"1.0.0\"),\n        openapi.WithInfoDescription(\"CRUD operations for user management\"),\n        openapi.WithServer(\"https://api.example.com\", \"Production\"),\n        openapi.WithServer(\"http://localhost:8080\", \"Development\"),\n    )\n\n    // Generate spec from operations\n    result, err := api.Generate(context.Background(),\n        // List users\n        openapi.GET(\"/users\",\n            openapi.WithSummary(\"List all users\"),\n            openapi.WithResponse(200, []User{}),\n        ),\n\n        // Get user by ID\n        openapi.GET(\"/users/:id\",\n            openapi.WithSummary(\"Get user by ID\"),\n            openapi.WithRequest(GetUserRequest{}),\n            openapi.WithResponse(200, User{}),\n            openapi.WithResponse(404, ErrorResponse{}),\n        ),\n\n        // Create user\n        openapi.POST(\"/users\",\n            openapi.WithSummary(\"Create new user\"),\n            openapi.WithRequest(CreateUserRequest{}),\n            openapi.WithResponse(201, User{}),\n            openapi.WithResponse(400, ErrorResponse{}),\n        ),\n\n        // Update user\n        openapi.PUT(\"/users/:id\",\n            openapi.WithSummary(\"Update user\"),\n            openapi.WithRequest(UpdateUserRequest{}),\n            openapi.WithResponse(200, User{}),\n            openapi.WithResponse(404, ErrorResponse{}),\n        ),\n\n        // Delete user\n        openapi.DELETE(\"/users/:id\",\n            openapi.WithSummary(\"Delete user\"),\n            openapi.WithRequest(GetUserRequest{}),\n            openapi.WithResponse(204, nil),\n            openapi.WithResponse(404, ErrorResponse{}),\n        ),\n    )\n\n    if err != nil {\n        panic(err)\n    }\n\n    // Save to file\n    fmt.Println(string(result.JSON))\n}\n</code></pre>"},{"location":"getting-started/quick-start/#understanding-the-output","title":"Understanding the Output","text":"<p>The generated specification includes everything you'd expect:</p> <ul> <li>Path parameters from <code>:id</code> in URLs</li> <li>Request bodies from <code>body:\"structured\"</code> tags</li> <li>Response schemas from plain structs or wrapped types</li> <li>Schema constraints from <code>validate</code> tags</li> <li>Component schemas for reusable types</li> <li>Multiple responses with status codes</li> </ul> <p>Here's the structure:</p> <pre><code>{\n  \"openapi\": \"3.1.2\",\n  \"info\": {\n    \"title\": \"User Management API\",\n    \"version\": \"1.0.0\",\n    \"description\": \"CRUD operations for user management\"\n  },\n  \"servers\": [\n    {\n      \"url\": \"https://api.example.com\",\n      \"description\": \"Production\"\n    }\n  ],\n  \"paths\": {\n    \"/users\": {\n      \"get\": { ... },\n      \"post\": { ... }\n    },\n    \"/users/{id}\": {\n      \"get\": { ... },\n      \"put\": { ... },\n      \"delete\": { ... }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"User\": { ... },\n      \"CreateUserRequestBody\": { ... }\n    }\n  }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#adding-security","title":"Adding Security","text":"<p>Protect endpoints with authentication:</p> <pre><code>api := openapi.NewAPI(\n    openapi.WithInfoTitle(\"User API\"),\n    openapi.WithInfoVersion(\"1.0.0\"),\n    openapi.WithBearerAuth(\"bearerAuth\", \"JWT authentication\"),\n)\n\nresult, _ := api.Generate(context.Background(),\n    openapi.POST(\"/users\",\n        openapi.WithRequest(CreateUserRequest{}),\n        openapi.WithResponse(201, User{}),\n        openapi.WithSecurity(\"bearerAuth\"), // Requires auth\n    ),\n)\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you've generated your first spec:</p> <ul> <li>Core Concepts - Learn how the library works</li> <li>Tag Reference (talav/schema) - Complete <code>schema</code>/<code>body</code> tag semantics</li> <li>Validation - Transform validation rules to schemas</li> </ul>"},{"location":"guides/examples/","title":"Examples","text":"<p>Generate realistic examples for your API documentation.</p>"},{"location":"guides/examples/#how-examples-are-defined","title":"How Examples Are Defined","text":"<p>This library does not auto-generate example payloads from Go types or validation rules. Examples are defined explicitly:</p> <ul> <li>Field-level examples via the <code>openapi:\"examples=...\"</code> tag</li> <li>Operation-level examples via <code>openapi/example</code> helpers (<code>WithRequestExample</code>, <code>WithResponseExample</code>)</li> </ul>"},{"location":"guides/examples/#field-level-examples","title":"Field-Level Examples","text":"<p>Define examples using the <code>openapi</code> tag:</p>"},{"location":"guides/examples/#single-example","title":"Single Example","text":"<pre><code>type User struct {\n    Name  string `json:\"name\" openapi:\"examples=John Doe\"`\n    Email string `json:\"email\" openapi:\"examples=john@example.com\"`\n    Age   int    `json:\"age\" openapi:\"examples=30\"`\n}\n</code></pre>"},{"location":"guides/examples/#multiple-examples","title":"Multiple Examples","text":"<p>Separate examples with <code>|</code>:</p> <pre><code>type Product struct {\n    Name  string  `json:\"name\" openapi:\"examples=Widget|Gadget|Tool\"`\n    Price float64 `json:\"price\" openapi:\"examples=9.99|19.99|29.99\"`\n}\n</code></pre> <p>The first example is used as the default.</p>"},{"location":"guides/examples/#operation-level-examples","title":"Operation-Level Examples","text":"<p>Add examples to entire requests/responses:</p> <pre><code>import \"github.com/talav/openapi/example\"\n\n// Create example instance\nuserExample := example.New(\"john_doe\",\n    example.WithSummary(\"Example user\"),\n    example.WithDescription(\"A typical user account\"),\n    example.WithValue(map[string]any{\n        \"id\":    42,\n        \"name\":  \"John Doe\",\n        \"email\": \"john@example.com\",\n        \"role\":  \"admin\",\n    }),\n)\n\n// Apply to operation\nopenapi.POST(\"/users\",\n    openapi.WithRequest(CreateUserRequest{}),\n    openapi.WithRequestExample(userExample),\n    openapi.WithResponse(201, User{}),\n)\n</code></pre>"},{"location":"guides/examples/#multiple-request-examples","title":"Multiple Request Examples","text":"<pre><code>adminExample := example.New(\"admin_user\",\n    example.WithSummary(\"Admin user\"),\n    example.WithValue(map[string]any{\n        \"name\":  \"Admin User\",\n        \"email\": \"admin@example.com\",\n        \"role\":  \"admin\",\n    }),\n)\n\nregularExample := example.New(\"regular_user\",\n    example.WithSummary(\"Regular user\"),\n    example.WithValue(map[string]any{\n        \"name\":  \"Regular User\",\n        \"email\": \"user@example.com\",\n        \"role\":  \"user\",\n    }),\n)\n\nopenapi.POST(\"/users\",\n    openapi.WithRequest(CreateUserRequest{}),\n    openapi.WithRequestExample(adminExample),\n    openapi.WithRequestExample(regularExample),\n    openapi.WithResponse(201, User{}),\n)\n</code></pre>"},{"location":"guides/examples/#response-examples","title":"Response Examples","text":""},{"location":"guides/examples/#success-example","title":"Success Example","text":"<pre><code>successExample := example.New(\"success\",\n    example.WithSummary(\"Successful creation\"),\n    example.WithValue(map[string]any{\n        \"id\":         123,\n        \"name\":       \"New User\",\n        \"email\":      \"user@example.com\",\n        \"created_at\": \"2024-03-15T10:30:00Z\",\n    }),\n)\n\nopenapi.POST(\"/users\",\n    openapi.WithRequest(CreateUserRequest{}),\n    openapi.WithResponse(201, User{},\n        openapi.WithResponseExample(successExample),\n    ),\n)\n</code></pre>"},{"location":"guides/examples/#error-examples","title":"Error Examples","text":"<pre><code>notFoundExample := example.New(\"not_found\",\n    example.WithSummary(\"User not found\"),\n    example.WithValue(map[string]any{\n        \"error\":   \"not_found\",\n        \"message\": \"User with ID 999 does not exist\",\n    }),\n)\n\nvalidationExample := example.New(\"validation_error\",\n    example.WithSummary(\"Validation failed\"),\n    example.WithValue(map[string]any{\n        \"error\": \"validation_failed\",\n        \"details\": []map[string]string{\n            {\"field\": \"email\", \"message\": \"invalid email format\"},\n            {\"field\": \"age\", \"message\": \"must be at least 18\"},\n        },\n    }),\n)\n\nopenapi.POST(\"/users\",\n    openapi.WithRequest(CreateUserRequest{}),\n    openapi.WithResponse(201, User{}),\n    openapi.WithResponse(400, Error{},\n        openapi.WithResponseExample(validationExample),\n    ),\n    openapi.WithResponse(404, Error{},\n        openapi.WithResponseExample(notFoundExample),\n    ),\n)\n</code></pre>"},{"location":"guides/examples/#complex-examples","title":"Complex Examples","text":""},{"location":"guides/examples/#nested-structures","title":"Nested Structures","text":"<pre><code>type Order struct {\n    ID    int     `json:\"id\"`\n    Items []Item  `json:\"items\"`\n    User  User    `json:\"user\"`\n    Total float64 `json:\"total\"`\n}\n\norderExample := example.New(\"sample_order\",\n    example.WithValue(map[string]any{\n        \"id\": 789,\n        \"items\": []map[string]any{\n            {\"id\": 1, \"name\": \"Widget\", \"price\": 9.99, \"quantity\": 2},\n            {\"id\": 2, \"name\": \"Gadget\", \"price\": 19.99, \"quantity\": 1},\n        },\n        \"user\": map[string]any{\n            \"id\":    42,\n            \"name\":  \"John Doe\",\n            \"email\": \"john@example.com\",\n        },\n        \"total\": 39.97,\n    }),\n)\n</code></pre>"},{"location":"guides/examples/#arrays","title":"Arrays","text":"<pre><code>usersExample := example.New(\"user_list\",\n    example.WithSummary(\"List of users\"),\n    example.WithValue([]map[string]any{\n        {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n        {\"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\"},\n        {\"id\": 3, \"name\": \"Charlie\", \"email\": \"charlie@example.com\"},\n    }),\n)\n\nopenapi.GET(\"/users\",\n    openapi.WithResponse(200, []User{},\n        openapi.WithResponseExample(usersExample),\n    ),\n)\n</code></pre>"},{"location":"guides/examples/#parameter-examples","title":"Parameter Examples","text":"<p>Examples for query/path/header parameters:</p> <pre><code>type SearchRequest struct {\n    Query    string   `schema:\"q\" openapi:\"examples=golang|kubernetes|docker\"`\n    Category string   `schema:\"category\" openapi:\"examples=tutorial|reference\"`\n    Tags     []string `schema:\"tags\" openapi:\"examples=beginner|advanced\"`\n    Page     int      `schema:\"page\" default:\"1\" openapi:\"examples=1|2|5\"`\n}\n</code></pre>"},{"location":"guides/examples/#external-examples","title":"External Examples","text":"<p>Reference examples from external URLs:</p> <pre><code>externalExample := example.New(\"external_user\",\n    example.WithSummary(\"User from external source\"),\n    example.WithExternalValue(\"https://example.com/examples/user.json\"),\n)\n</code></pre>"},{"location":"guides/examples/#complete-example","title":"Complete Example","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"github.com/talav/openapi\"\n    \"github.com/talav/openapi/example\"\n)\n\nfunc main() {\n    api := openapi.NewAPI(\n        openapi.WithInfoTitle(\"User API\"),\n        openapi.WithInfoVersion(\"1.0.0\"),\n    )\n\n    // Success examples\n    userCreated := example.New(\"user_created\",\n        example.WithSummary(\"Successfully created user\"),\n        example.WithValue(map[string]any{\n            \"id\":         123,\n            \"name\":       \"Alice Johnson\",\n            \"email\":      \"alice@company.com\",\n            \"role\":       \"user\",\n            \"created_at\": \"2024-03-15T10:30:00Z\",\n        }),\n    )\n\n    // Error examples\n    invalidEmail := example.New(\"invalid_email\",\n        example.WithSummary(\"Invalid email format\"),\n        example.WithValue(map[string]any{\n            \"error\":   \"validation_error\",\n            \"message\": \"email must be a valid email address\",\n            \"field\":   \"email\",\n        }),\n    )\n\n    duplicateEmail := example.New(\"duplicate_email\",\n        example.WithSummary(\"Email already registered\"),\n        example.WithValue(map[string]any{\n            \"error\":   \"conflict\",\n            \"message\": \"A user with this email already exists\",\n            \"field\":   \"email\",\n        }),\n    )\n\n    result, _ := api.Generate(context.Background(),\n        openapi.POST(\"/users\",\n            openapi.WithRequest(CreateUserRequest{}),\n            openapi.WithResponse(201, User{},\n                openapi.WithResponseExample(userCreated),\n            ),\n            openapi.WithResponse(400, Error{},\n                openapi.WithResponseExample(invalidEmail),\n            ),\n            openapi.WithResponse(409, Error{},\n                openapi.WithResponseExample(duplicateEmail),\n            ),\n        ),\n    )\n}\n</code></pre>"},{"location":"guides/examples/#next-steps","title":"Next Steps","text":"<ul> <li>OpenAPI Versions - Example format differences</li> <li>Metadata - Field-level examples with <code>openapi</code> tag</li> </ul>"},{"location":"guides/metadata/","title":"Metadata","text":"<p>Add rich OpenAPI metadata using the <code>openapi</code>, <code>default</code>, and <code>requires</code> tags.</p>"},{"location":"guides/metadata/#the-openapi-tag","title":"The <code>openapi</code> Tag","text":"<p>The <code>openapi</code> tag adds OpenAPI-specific properties that don't affect validation.</p>"},{"location":"guides/metadata/#basic-properties","title":"Basic Properties","text":"<pre><code>type Product struct {\n    ID    string `json:\"id\" openapi:\"readOnly\"`\n    Name  string `json:\"name\" openapi:\"title=Product Name\"`\n    Price float64 `json:\"price\" openapi:\"description=Price in USD\"`\n}\n</code></pre>"},{"location":"guides/metadata/#field-level-options","title":"Field-Level Options","text":"Option Description Example <code>readOnly</code> Field appears in responses only <code>openapi:\"readOnly\"</code> <code>writeOnly</code> Field appears in requests only <code>openapi:\"writeOnly\"</code> <code>deprecated</code> Field is deprecated <code>openapi:\"deprecated\"</code> <code>hidden</code> Exclude from schema <code>openapi:\"hidden\"</code> <code>required</code> Override required status <code>openapi:\"required\"</code> <code>title</code> Schema title <code>openapi:\"title=User ID\"</code> <code>description</code> Field description <code>openapi:\"description=Unique identifier\"</code> <code>format</code> Data format hint <code>openapi:\"format=date-time\"</code> <code>examples</code> Example values <code>openapi:\"examples=val1|val2\"</code>"},{"location":"guides/metadata/#readonly-and-writeonly","title":"ReadOnly and WriteOnly","text":"<p>Useful for fields that appear in only one direction:</p> <pre><code>type User struct {\n    // Server-generated, appears only in responses\n    ID        int       `json:\"id\" openapi:\"readOnly\"`\n    CreatedAt time.Time `json:\"created_at\" openapi:\"readOnly\"`\n\n    // Sent in requests, never returned\n    Password string `json:\"password\" openapi:\"writeOnly\"`\n\n    // Appears in both\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}\n</code></pre>"},{"location":"guides/metadata/#deprecated-fields","title":"Deprecated Fields","text":"<p>Mark fields as deprecated to signal future removal:</p> <pre><code>type User struct {\n    Name     string `json:\"name\"`\n    FullName string `json:\"full_name\"` // New field\n    Username string `json:\"username\" openapi:\"deprecated\"` // Old field\n}\n</code></pre>"},{"location":"guides/metadata/#hidden-fields","title":"Hidden Fields","text":"<p>Exclude fields from the generated schema:</p> <pre><code>type User struct {\n    ID       int    `json:\"id\"`\n    Name     string `json:\"name\"`\n    Internal string `json:\"internal\" openapi:\"hidden\"` // Not in spec\n}\n</code></pre>"},{"location":"guides/metadata/#examples","title":"Examples","text":"<p>Provide example values for documentation:</p> <pre><code>type Product struct {\n    Name  string  `json:\"name\" openapi:\"examples=Widget|Gadget|Tool\"`\n    Price float64 `json:\"price\" openapi:\"examples=9.99|19.99|29.99\"`\n    SKU   string  `json:\"sku\" openapi:\"examples=WDG-001\"`\n}\n</code></pre> <p>Multiple examples separated by <code>|</code>.</p>"},{"location":"guides/metadata/#format-hints","title":"Format Hints","text":"<p>Specify data formats beyond standard JSON Schema formats:</p> <pre><code>type Event struct {\n    Date     string `json:\"date\" openapi:\"format=date\"`          // yyyy-mm-dd\n    Time     string `json:\"time\" openapi:\"format=time\"`          // hh:mm:ss\n    DateTime string `json:\"datetime\" openapi:\"format=date-time\"` // RFC3339\n    Duration string `json:\"duration\" openapi:\"format=duration\"`   // ISO 8601\n}\n</code></pre>"},{"location":"guides/metadata/#custom-extensions","title":"Custom Extensions","text":"<p>Add vendor-specific extensions (must start with <code>x-</code>):</p> <pre><code>type User struct {\n    ID int `json:\"id\" openapi:\"x-internal-id=users,x-searchable=true\"`\n}\n</code></pre> <p>Generates:</p> <pre><code>{\n  \"id\": {\n    \"type\": \"integer\",\n    \"x-internal-id\": \"users\",\n    \"x-searchable\": true\n  }\n}\n</code></pre>"},{"location":"guides/metadata/#the-default-tag","title":"The <code>default</code> Tag","text":"<p>Specify default values for optional fields:</p> <pre><code>type Config struct {\n    Host    string `json:\"host\" default:\"localhost\"`\n    Port    int    `json:\"port\" default:\"8080\"`\n    Debug   bool   `json:\"debug\" default:\"false\"`\n    Timeout int    `json:\"timeout\" default:\"30\"`\n}\n</code></pre> <p>Generates:</p> <pre><code>{\n  \"host\": {\n    \"type\": \"string\",\n    \"default\": \"localhost\"\n  },\n  \"port\": {\n    \"type\": \"integer\",\n    \"default\": 8080\n  }\n}\n</code></pre>"},{"location":"guides/metadata/#type-conversion","title":"Type Conversion","text":"<p>Default values are automatically converted to the correct type:</p> <pre><code>type Settings struct {\n    Count   int     `json:\"count\" default:\"10\"`      // String \u2192 int\n    Enabled bool    `json:\"enabled\" default:\"true\"`  // String \u2192 bool\n    Rate    float64 `json:\"rate\" default:\"0.5\"`      // String \u2192 float64\n}\n</code></pre>"},{"location":"guides/metadata/#the-requires-tag","title":"The <code>requires</code> Tag","text":"<p>Specify conditional required fields (OpenAPI 3.1 <code>dependentRequired</code>):</p> <pre><code>type Payment struct {\n    Method     string `json:\"method\"`\n    CardNumber string `json:\"card_number\" requires:\"cvv,expiry\"`\n    CVV        string `json:\"cvv\"`\n    Expiry     string `json:\"expiry\"`\n}\n</code></pre> <p>When <code>card_number</code> is present, <code>cvv</code> and <code>expiry</code> become required.</p> <p>Generates:</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"method\": { \"type\": \"string\" },\n    \"card_number\": { \"type\": \"string\" },\n    \"cvv\": { \"type\": \"string\" },\n    \"expiry\": { \"type\": \"string\" }\n  },\n  \"dependentRequired\": {\n    \"card_number\": [\"cvv\", \"expiry\"]\n  }\n}\n</code></pre>"},{"location":"guides/metadata/#multiple-dependencies","title":"Multiple Dependencies","text":"<pre><code>type Form struct {\n    Type         string `json:\"type\"`\n    PersonName   string `json:\"person_name\" requires:\"person_age\"`\n    PersonAge    int    `json:\"person_age\"`\n    CompanyName  string `json:\"company_name\" requires:\"company_tax_id\"`\n    CompanyTaxID string `json:\"company_tax_id\"`\n}\n</code></pre>"},{"location":"guides/metadata/#struct-level-metadata","title":"Struct-Level Metadata","text":"<p>Use the blank identifier <code>_</code> for struct-level properties:</p> <pre><code>type User struct {\n    _ struct{} `openapi:\"additionalProperties=false,nullable=true\"`\n\n    ID   int    `json:\"id\"`\n    Name string `json:\"name\"`\n}\n</code></pre> <ul> <li><code>additionalProperties=false</code>: Disallow extra properties</li> <li><code>nullable=true</code>: Allow null values for the entire object</li> </ul>"},{"location":"guides/metadata/#combining-tags","title":"Combining Tags","text":"<p>Use multiple tags together for complete schemas:</p> <pre><code>type User struct {\n    ID    int    `json:\"id\" openapi:\"readOnly,title=User ID,description=Unique identifier,examples=1|42|100\"`\n    Name  string `json:\"name\" validate:\"required,min=3,max=50\" openapi:\"title=Full Name,description=User's display name,examples=John Doe|Jane Smith\"`\n    Email string `json:\"email\" validate:\"required,email\" openapi:\"description=Contact email,examples=user@example.com\" default:\"\"`\n    Age   int    `json:\"age\" validate:\"min=18\" openapi:\"description=Age in years\" default:\"18\"`\n}\n</code></pre>"},{"location":"guides/metadata/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - Generate examples automatically</li> <li>Security - Add authentication schemes</li> <li>Advanced Hooks - Transform schemas programmatically</li> </ul>"},{"location":"guides/security/","title":"Security","text":"<p>Configure OpenAPI security schemes for authentication and authorization.</p>"},{"location":"guides/security/#overview","title":"Overview","text":"<p>The library supports all OpenAPI 3.0/3.1 security scheme types:</p> <ul> <li>HTTP Authentication (Basic, Bearer, etc.)</li> <li>API Keys (Header, Query, Cookie)</li> <li>OAuth 2.0</li> <li>OpenID Connect</li> </ul>"},{"location":"guides/security/#http-authentication","title":"HTTP Authentication","text":""},{"location":"guides/security/#bearer-authentication-jwt","title":"Bearer Authentication (JWT)","text":"<p>Most common for modern APIs:</p> <pre><code>api := openapi.NewAPI(\n    openapi.WithInfoTitle(\"My API\"),\n    openapi.WithInfoVersion(\"1.0.0\"),\n    openapi.WithBearerAuth(\"bearerAuth\", \"JWT authentication\"),\n)\n\nresult, _ := api.Generate(context.Background(),\n    openapi.POST(\"/users\",\n        openapi.WithRequest(CreateUserRequest{}),\n        openapi.WithResponse(201, User{}),\n        openapi.WithSecurity(\"bearerAuth\"), // Requires auth\n    ),\n\n    // Public endpoint (no auth)\n    openapi.GET(\"/public/info\",\n        openapi.WithResponse(200, Info{}),\n    ),\n)\n</code></pre> <p>Generates:</p> <pre><code>{\n  \"components\": {\n    \"securitySchemes\": {\n      \"bearerAuth\": {\n        \"type\": \"http\",\n        \"scheme\": \"bearer\",\n        \"bearerFormat\": \"JWT\",\n        \"description\": \"JWT authentication\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"guides/security/#basic-authentication","title":"Basic Authentication","text":"<pre><code>api.AddSecurityScheme(\"basicAuth\", openapi.SecurityScheme{\n    Type:        \"http\",\n    Scheme:      \"basic\",\n    Description: \"Basic HTTP authentication\",\n})\n</code></pre>"},{"location":"guides/security/#custom-http-schemes","title":"Custom HTTP Schemes","text":"<pre><code>api.AddSecurityScheme(\"digestAuth\", openapi.SecurityScheme{\n    Type:        \"http\",\n    Scheme:      \"digest\",\n    Description: \"Digest authentication\",\n})\n</code></pre>"},{"location":"guides/security/#api-key-authentication","title":"API Key Authentication","text":""},{"location":"guides/security/#header-based-api-keys","title":"Header-Based API Keys","text":"<pre><code>api.AddSecurityScheme(\"apiKey\", openapi.SecurityScheme{\n    Type:        \"apiKey\",\n    In:          \"header\",\n    Name:        \"X-API-Key\",\n    Description: \"API key for external integrations\",\n})\n</code></pre> <p>Usage:</p> <pre><code>GET /users\nX-API-Key: your-api-key-here\n</code></pre>"},{"location":"guides/security/#query-parameter-api-keys","title":"Query Parameter API Keys","text":"<pre><code>api.AddSecurityScheme(\"apiKeyQuery\", openapi.SecurityScheme{\n    Type:        \"apiKey\",\n    In:          \"query\",\n    Name:        \"api_key\",\n    Description: \"API key in query string\",\n})\n</code></pre> <p>Usage:</p> <pre><code>GET /users?api_key=your-api-key-here\n</code></pre>"},{"location":"guides/security/#cookie-based-api-keys","title":"Cookie-Based API Keys","text":"<pre><code>api.AddSecurityScheme(\"cookieAuth\", openapi.SecurityScheme{\n    Type:        \"apiKey\",\n    In:          \"cookie\",\n    Name:        \"session_id\",\n    Description: \"Session cookie\",\n})\n</code></pre>"},{"location":"guides/security/#oauth-20","title":"OAuth 2.0","text":""},{"location":"guides/security/#authorization-code-flow","title":"Authorization Code Flow","text":"<p>For web applications with backend:</p> <pre><code>api.WithOAuth2Auth(\"oauth2\", \"OAuth 2.0 authentication\",\n    openapi.WithAuthorizationCodeFlow(\n        \"https://auth.example.com/oauth/authorize\",\n        \"https://auth.example.com/oauth/token\",\n        map[string]string{\n            \"read:users\":  \"Read user data\",\n            \"write:users\": \"Modify user data\",\n            \"admin\":       \"Administrative access\",\n        },\n    ),\n)\n</code></pre>"},{"location":"guides/security/#implicit-flow","title":"Implicit Flow","text":"<p>For single-page applications (deprecated in OAuth 2.1):</p> <pre><code>api.WithOAuth2Auth(\"oauth2Implicit\", \"OAuth 2.0 Implicit\",\n    openapi.WithImplicitFlow(\n        \"https://auth.example.com/oauth/authorize\",\n        map[string]string{\n            \"read\": \"Read access\",\n        },\n    ),\n)\n</code></pre>"},{"location":"guides/security/#client-credentials-flow","title":"Client Credentials Flow","text":"<p>For server-to-server authentication:</p> <pre><code>api.WithOAuth2Auth(\"oauth2Client\", \"OAuth 2.0 Client Credentials\",\n    openapi.WithClientCredentialsFlow(\n        \"https://auth.example.com/oauth/token\",\n        map[string]string{\n            \"api:access\": \"API access\",\n        },\n    ),\n)\n</code></pre>"},{"location":"guides/security/#password-flow","title":"Password Flow","text":"<p>For trusted applications (deprecated in OAuth 2.1):</p> <pre><code>api.WithOAuth2Auth(\"oauth2Password\", \"OAuth 2.0 Password\",\n    openapi.WithPasswordFlow(\n        \"https://auth.example.com/oauth/token\",\n        map[string]string{\n            \"read\": \"Read access\",\n            \"write\": \"Write access\",\n        },\n    ),\n)\n</code></pre>"},{"location":"guides/security/#multiple-flows","title":"Multiple Flows","text":"<p>Combine flows for different client types:</p> <pre><code>api.AddSecurityScheme(\"oauth2Multi\", openapi.SecurityScheme{\n    Type:        \"oauth2\",\n    Description: \"OAuth 2.0\",\n    Flows: &amp;openapi.OAuthFlows{\n        AuthorizationCode: &amp;openapi.OAuthFlow{\n            AuthorizationURL: \"https://auth.example.com/authorize\",\n            TokenURL:         \"https://auth.example.com/token\",\n            Scopes: map[string]string{\n                \"read\":  \"Read access\",\n                \"write\": \"Write access\",\n            },\n        },\n        ClientCredentials: &amp;openapi.OAuthFlow{\n            TokenURL: \"https://auth.example.com/token\",\n            Scopes: map[string]string{\n                \"api\": \"API access\",\n            },\n        },\n    },\n})\n</code></pre>"},{"location":"guides/security/#openid-connect","title":"OpenID Connect","text":"<pre><code>api.WithOpenIDConnectAuth(\"oidc\", \"OpenID Connect\",\n    \"https://auth.example.com/.well-known/openid-configuration\",\n)\n</code></pre>"},{"location":"guides/security/#applying-security-to-operations","title":"Applying Security to Operations","text":""},{"location":"guides/security/#single-security-scheme","title":"Single Security Scheme","text":"<pre><code>openapi.POST(\"/users\",\n    openapi.WithRequest(CreateUserRequest{}),\n    openapi.WithResponse(201, User{}),\n    openapi.WithSecurity(\"bearerAuth\"),\n)\n</code></pre>"},{"location":"guides/security/#multiple-security-schemes-and","title":"Multiple Security Schemes (AND)","text":"<p>Requires ALL schemes:</p> <pre><code>openapi.POST(\"/admin/users\",\n    openapi.WithRequest(CreateUserRequest{}),\n    openapi.WithResponse(201, User{}),\n    openapi.WithSecurity(\"bearerAuth\", \"apiKey\"), // Both required\n)\n</code></pre>"},{"location":"guides/security/#alternative-security-schemes-or","title":"Alternative Security Schemes (OR)","text":"<p>Accepts ANY scheme:</p> <pre><code>// Method 1: Multiple WithSecurity calls\nopenapi.GET(\"/users\",\n    openapi.WithResponse(200, []User{}),\n    openapi.WithSecurity(\"bearerAuth\"),\n    openapi.WithSecurity(\"apiKey\"), // Alternative\n)\n\n// Method 2: Pass empty strings to separate alternatives\nopenapi.GET(\"/users\",\n    openapi.WithResponse(200, []User{}),\n    openapi.WithSecurity(\"bearerAuth\"),\n    openapi.WithSecurity(\"\"), // OR separator\n    openapi.WithSecurity(\"apiKey\"),\n)\n</code></pre>"},{"location":"guides/security/#oauth-scopes","title":"OAuth Scopes","text":"<p>Specify required OAuth scopes per operation:</p> <pre><code>api.WithOAuth2Auth(\"oauth2\", \"OAuth 2.0\",\n    openapi.WithAuthorizationCodeFlow(\n        \"https://auth.example.com/authorize\",\n        \"https://auth.example.com/token\",\n        map[string]string{\n            \"users:read\":  \"Read users\",\n            \"users:write\": \"Write users\",\n            \"admin\":       \"Admin access\",\n        },\n    ),\n)\n\n// Read operation - requires read scope\nopenapi.GET(\"/users\",\n    openapi.WithResponse(200, []User{}),\n    openapi.WithOAuthScopes(\"oauth2\", \"users:read\"),\n)\n\n// Write operation - requires write scope\nopenapi.POST(\"/users\",\n    openapi.WithRequest(CreateUserRequest{}),\n    openapi.WithResponse(201, User{}),\n    openapi.WithOAuthScopes(\"oauth2\", \"users:write\"),\n)\n\n// Admin operation - requires both scopes\nopenapi.DELETE(\"/users/:id\",\n    openapi.WithRequest(DeleteUserRequest{}),\n    openapi.WithResponse(204, nil),\n    openapi.WithOAuthScopes(\"oauth2\", \"users:write\", \"admin\"),\n)\n</code></pre>"},{"location":"guides/security/#global-security","title":"Global Security","text":"<p>Apply security to all operations by default:</p> <pre><code>api := openapi.NewAPI(\n    openapi.WithInfoTitle(\"My API\"),\n    openapi.WithInfoVersion(\"1.0.0\"),\n    openapi.WithBearerAuth(\"bearerAuth\", \"JWT auth\"),\n    openapi.WithGlobalSecurity(\"bearerAuth\"), // All operations require auth\n)\n\nresult, _ := api.Generate(context.Background(),\n    // Inherits global security\n    openapi.GET(\"/users\",\n        openapi.WithResponse(200, []User{}),\n    ),\n\n    // Override to make public\n    openapi.GET(\"/public/status\",\n        openapi.WithResponse(200, Status{}),\n        openapi.WithoutSecurity(), // No auth required\n    ),\n)\n</code></pre>"},{"location":"guides/security/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/security/#multi-tenant-api-keys","title":"Multi-Tenant API Keys","text":"<pre><code>api.AddSecurityScheme(\"tenantAuth\", openapi.SecurityScheme{\n    Type:        \"apiKey\",\n    In:          \"header\",\n    Name:        \"X-Tenant-ID\",\n    Description: \"Tenant identifier\",\n})\n\napi.AddSecurityScheme(\"apiKey\", openapi.SecurityScheme{\n    Type:        \"apiKey\",\n    In:          \"header\",\n    Name:        \"X-API-Key\",\n    Description: \"API key\",\n})\n\n// Requires both tenant ID and API key\nopenapi.GET(\"/data\",\n    openapi.WithResponse(200, Data{}),\n    openapi.WithSecurity(\"tenantAuth\", \"apiKey\"),\n)\n</code></pre>"},{"location":"guides/security/#mixed-public-and-private-endpoints","title":"Mixed Public and Private Endpoints","text":"<pre><code>api := openapi.NewAPI(\n    openapi.WithBearerAuth(\"bearerAuth\", \"JWT auth\"),\n)\n\nresult, _ := api.Generate(context.Background(),\n    // Public endpoints\n    openapi.GET(\"/public/products\",\n        openapi.WithResponse(200, []Product{}),\n    ),\n    openapi.GET(\"/public/pricing\",\n        openapi.WithResponse(200, Pricing{}),\n    ),\n\n    // Protected endpoints\n    openapi.POST(\"/users\",\n        openapi.WithRequest(CreateUserRequest{}),\n        openapi.WithResponse(201, User{}),\n        openapi.WithSecurity(\"bearerAuth\"),\n    ),\n    openapi.GET(\"/users/me\",\n        openapi.WithResponse(200, User{}),\n        openapi.WithSecurity(\"bearerAuth\"),\n    ),\n)\n</code></pre>"},{"location":"guides/security/#admin-endpoints-with-extra-security","title":"Admin Endpoints with Extra Security","text":"<pre><code>api.WithBearerAuth(\"userAuth\", \"User JWT\")\napi.WithAPIKeyAuth(\"adminKey\", \"X-Admin-Key\", \"header\", \"Admin API key\")\n\n// Regular user endpoints\nopenapi.GET(\"/profile\",\n    openapi.WithResponse(200, Profile{}),\n    openapi.WithSecurity(\"userAuth\"),\n)\n\n// Admin endpoints require BOTH auth methods\nopenapi.POST(\"/admin/users\",\n    openapi.WithRequest(CreateUserRequest{}),\n    openapi.WithResponse(201, User{}),\n    openapi.WithSecurity(\"userAuth\", \"adminKey\"),\n)\n</code></pre>"},{"location":"guides/security/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - Add example requests with auth headers</li> <li>Versions - Security differences between 3.0 and 3.1</li> </ul>"},{"location":"guides/validation/","title":"Validation","text":"<p>Transform Go validation tags into OpenAPI schema constraints.</p>"},{"location":"guides/validation/#overview","title":"Overview","text":"<p>The <code>validate</code> tag (from go-playground/validator) is automatically converted to OpenAPI/JSON Schema validation rules. This keeps your validation logic and API documentation in sync.</p>"},{"location":"guides/validation/#string-validation","title":"String Validation","text":""},{"location":"guides/validation/#required-fields","title":"Required Fields","text":"<pre><code>type User struct {\n    Name  string `json:\"name\" validate:\"required\"`\n    Email string `json:\"email\" validate:\"required,email\"`\n}\n</code></pre> <p>Generates:</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": { \"type\": \"string\" },\n    \"email\": { \"type\": \"string\", \"format\": \"email\" }\n  },\n  \"required\": [\"name\", \"email\"]\n}\n</code></pre>"},{"location":"guides/validation/#length-constraints","title":"Length Constraints","text":"<pre><code>type User struct {\n    Username string `json:\"username\" validate:\"min=3,max=20\"`\n    Bio      string `json:\"bio\" validate:\"max=500\"`\n    Code     string `json:\"code\" validate:\"len=6\"` // Exact length\n}\n</code></pre> <p>Becomes:</p> <pre><code>{\n  \"username\": {\n    \"type\": \"string\",\n    \"minLength\": 3,\n    \"maxLength\": 20\n  },\n  \"bio\": {\n    \"type\": \"string\",\n    \"maxLength\": 500\n  },\n  \"code\": {\n    \"type\": \"string\",\n    \"minLength\": 6,\n    \"maxLength\": 6\n  }\n}\n</code></pre>"},{"location":"guides/validation/#format-validation","title":"Format Validation","text":"<pre><code>type Contact struct {\n    Email string `json:\"email\" validate:\"email\"`\n    URL   string `json:\"url\" validate:\"url\"`\n    Phone string `json:\"phone\" validate:\"e164\"` // E.164 phone format\n}\n</code></pre> <p>Maps to OpenAPI formats:</p> <pre><code>{\n  \"email\": {\n    \"type\": \"string\",\n    \"format\": \"email\"\n  },\n  \"url\": {\n    \"type\": \"string\",\n    \"format\": \"uri\"\n  }\n}\n</code></pre>"},{"location":"guides/validation/#pattern-matching","title":"Pattern Matching","text":"<pre><code>type Product struct {\n    SKU  string `json:\"sku\" validate:\"pattern=^[A-Z]{3}-[0-9]{4}$\"`\n    Slug string `json:\"slug\" validate:\"pattern=^[a-z0-9-]+$\"`\n}\n</code></pre>"},{"location":"guides/validation/#numeric-validation","title":"Numeric Validation","text":""},{"location":"guides/validation/#range-constraints","title":"Range Constraints","text":"<pre><code>type Product struct {\n    Price    float64 `json:\"price\" validate:\"min=0,max=10000\"`\n    Quantity int     `json:\"quantity\" validate:\"min=1\"`\n    Rating   float64 `json:\"rating\" validate:\"min=0,max=5\"`\n    Age      int     `json:\"age\" validate:\"min=18,max=120\"`\n}\n</code></pre> <p>Generates:</p> <pre><code>{\n  \"price\": {\n    \"type\": \"number\",\n    \"minimum\": 0,\n    \"maximum\": 10000\n  },\n  \"quantity\": {\n    \"type\": \"integer\",\n    \"minimum\": 1\n  }\n}\n</code></pre>"},{"location":"guides/validation/#exclusive-bounds","title":"Exclusive Bounds","text":"<pre><code>type Range struct {\n    Value int `json:\"value\" validate:\"gt=0,lt=100\"` // 0 &lt; value &lt; 100\n}\n</code></pre> <p>Becomes:</p> <pre><code>{\n  \"value\": {\n    \"type\": \"integer\",\n    \"exclusiveMinimum\": 0,\n    \"exclusiveMaximum\": 100\n  }\n}\n</code></pre>"},{"location":"guides/validation/#multiple-of","title":"Multiple Of","text":"<pre><code>type Measurement struct {\n    Increment float64 `json:\"increment\" validate:\"multipleOf=0.5\"`\n    Count     int     `json:\"count\" validate:\"multipleOf=10\"`\n}\n</code></pre>"},{"location":"guides/validation/#array-validation","title":"Array Validation","text":""},{"location":"guides/validation/#size-constraints","title":"Size Constraints","text":"<pre><code>type Form struct {\n    Tags       []string `json:\"tags\" validate:\"min=1,max=5\"`\n    Signatures []string `json:\"signatures\" validate:\"min=2\"`\n    Options    []string `json:\"options\" validate:\"len=3\"` // Exactly 3\n}\n</code></pre> <p>Generates:</p> <pre><code>{\n  \"tags\": {\n    \"type\": \"array\",\n    \"items\": { \"type\": \"string\" },\n    \"minItems\": 1,\n    \"maxItems\": 5\n  }\n}\n</code></pre>"},{"location":"guides/validation/#unique-items","title":"Unique Items","text":"<pre><code>type List struct {\n    UniqueIDs []int `json:\"unique_ids\" validate:\"unique\"`\n}\n</code></pre>"},{"location":"guides/validation/#enum-validation","title":"Enum Validation","text":""},{"location":"guides/validation/#string-enums","title":"String Enums","text":"<pre><code>type Order struct {\n    Status string `json:\"status\" validate:\"oneof=pending processing shipped delivered\"`\n}\n</code></pre> <p>Becomes:</p> <pre><code>{\n  \"status\": {\n    \"type\": \"string\",\n    \"enum\": [\"pending\", \"processing\", \"shipped\", \"delivered\"]\n  }\n}\n</code></pre>"},{"location":"guides/validation/#numeric-enums","title":"Numeric Enums","text":"<pre><code>type Priority struct {\n    Level int `json:\"level\" validate:\"oneof=1 2 3 4 5\"`\n}\n</code></pre>"},{"location":"guides/validation/#combining-validators","title":"Combining Validators","text":"<p>Multiple validation rules work together:</p> <pre><code>type User struct {\n    Email    string `json:\"email\" validate:\"required,email,max=100\"`\n    Age      int    `json:\"age\" validate:\"required,min=18,max=120\"`\n    Username string `json:\"username\" validate:\"required,min=3,max=20,pattern=^[a-z0-9_]+$\"`\n}\n</code></pre>"},{"location":"guides/validation/#validation-mapping-reference","title":"Validation Mapping Reference","text":"Validator OpenAPI Property Example <code>required</code> <code>required</code> array <code>validate:\"required\"</code> <code>min=N</code> (string) <code>minLength</code> <code>validate:\"min=3\"</code> <code>max=N</code> (string) <code>maxLength</code> <code>validate:\"max=100\"</code> <code>len=N</code> (string) <code>minLength</code> + <code>maxLength</code> <code>validate:\"len=6\"</code> <code>min=N</code> (number) <code>minimum</code> <code>validate:\"min=0\"</code> <code>max=N</code> (number) <code>maximum</code> <code>validate:\"max=100\"</code> <code>gt=N</code> <code>exclusiveMinimum</code> <code>validate:\"gt=0\"</code> <code>lt=N</code> <code>exclusiveMaximum</code> <code>validate:\"lt=100\"</code> <code>multipleOf=N</code> <code>multipleOf</code> <code>validate:\"multipleOf=0.5\"</code> <code>email</code> <code>format: email</code> <code>validate:\"email\"</code> <code>url</code> <code>format: uri</code> <code>validate:\"url\"</code> <code>pattern=...</code> <code>pattern</code> <code>validate:\"pattern=^[a-z]+$\"</code> <code>oneof=...</code> <code>enum</code> <code>validate:\"oneof=a b c\"</code> <code>min=N</code> (array) <code>minItems</code> <code>validate:\"min=1\"</code> <code>max=N</code> (array) <code>maxItems</code> <code>validate:\"max=10\"</code> <code>unique</code> <code>uniqueItems</code> <code>validate:\"unique\"</code>"},{"location":"guides/validation/#overriding-with-openapi-tag","title":"Overriding with <code>openapi</code> Tag","text":"<p>You can override validation-derived required status:</p> <pre><code>type User struct {\n    // Required by validate, but optional in OpenAPI docs\n    Email string `json:\"email\" validate:\"required\" openapi:\"required=false\"`\n\n    // Optional in code, but required in OpenAPI docs\n    Name string `json:\"name\" openapi:\"required\"`\n}\n</code></pre>"},{"location":"guides/validation/#nested-validation","title":"Nested Validation","text":"<p>Validation works on nested structs:</p> <pre><code>type User struct {\n    Name    string  `json:\"name\" validate:\"required\"`\n    Address Address `json:\"address\" validate:\"required\"`\n}\n\ntype Address struct {\n    Street string `json:\"street\" validate:\"required\"`\n    City   string `json:\"city\" validate:\"required\"`\n    Zip    string `json:\"zip\" validate:\"required,len=5\"`\n}\n</code></pre> <p>All validation rules propagate to the generated schema.</p>"},{"location":"guides/validation/#complex-validation","title":"Complex Validation","text":""},{"location":"guides/validation/#conditional-required","title":"Conditional Required","text":"<p>Use the <code>requires</code> tag for fields that become required when another field is present:</p> <pre><code>type Payment struct {\n    Method     string `json:\"method\"`\n    CardNumber string `json:\"card_number\" requires:\"cvv,expiry\"`\n    CVV        string `json:\"cvv\"`\n    Expiry     string `json:\"expiry\"`\n}\n</code></pre> <p>In OpenAPI 3.1, this uses <code>dependentRequired</code>:</p> <pre><code>{\n  \"dependentRequired\": {\n    \"card_number\": [\"cvv\", \"expiry\"]\n  }\n}\n</code></pre>"},{"location":"guides/validation/#next-steps","title":"Next Steps","text":"<ul> <li>Metadata - Add descriptions, examples, and more</li> <li>Tag Reference (talav/schema) - Parameter and body tag semantics</li> </ul>"},{"location":"guides/versions/","title":"OpenAPI Versions","text":"<p>This library generates specifications for:</p> <ul> <li><code>3.0.4</code></li> <li><code>3.1.2</code></li> </ul>"},{"location":"guides/versions/#choosing-a-version","title":"Choosing a Version","text":"<p>Set the target version when creating the API:</p> <pre><code>// OpenAPI 3.0.4 (default)\napi := openapi.NewAPI(\n    openapi.WithVersion(\"3.0.4\"),\n)\n\n// OpenAPI 3.1.2\napi := openapi.NewAPI(\n    openapi.WithVersion(\"3.1.2\"),\n)\n</code></pre> <p>If <code>WithVersion</code> is omitted, the default target is <code>3.0.4</code>.</p>"},{"location":"guides/versions/#library-behavior","title":"Library Behavior","text":"<ul> <li>The same Go structs and operation definitions are used for both versions.</li> <li>The library projects output to the requested target version.</li> <li>If a feature cannot be represented in the target version, behavior depends on configuration (degrade with warnings vs strict errors).</li> </ul>"},{"location":"guides/versions/#external-specification-references","title":"External Specification References","text":"<p>For authoritative version semantics and compatibility details, use the official specs:</p> <ul> <li>OpenAPI 3.0.4 Specification</li> <li>OpenAPI 3.1.0/3.1.x Specification</li> <li>JSON Schema 2020-12</li> </ul>"},{"location":"guides/versions/#next-steps","title":"Next Steps","text":"<ul> <li>Security</li> <li>Advanced Hooks</li> </ul>"}]}